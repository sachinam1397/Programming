from pprint import pprint


LIMITS = {(-1, -1): 2, (-1, 1): 5, (1, -1): 4, (1, 1): 3}


class Node():
    def __init__(self, parent=None, pos=None):
        self.parent = parent
        self.pos = pos

        self.g = 0
        self.h = 0

    def __eq__(self, node):
        return self.pos == node.pos

    def f(self):
        return self.g + self.h


def get_path(src, dest):
    if sum(src) % 2 != sum(dest) % 2:
        return 'Invalid Points'

    src_node = Node(None, src)
    dest_node = Node(None, dest)

    open_list = []
    closed_list = []

    open_list.append(src_node)

    while len(open_list) > 0:
        curr_node = open_list[0]
        curr_index = 0
        for i in range(len(open_list)):
            node = open_list[i]
            if node.f() < curr_node.f():
                curr_node = node
                curr_index = i

        open_list.pop(curr_index)
        closed_list.append(curr_node)

        if curr_node == dest_node:
            path = []
            node = curr_node
            while node is not None:
                # path.append((node.pos, node.h))
                path.append(node.pos)
                node = node.parent
            return path[::-1]

        children = []
        possible_paths = []
        for path, limit in LIMITS.items():
            temp_node = curr_node
            prev_path = []
            for _ in range(limit):
                if temp_node.parent is None:
                    break

                prev_path.append(
                    (temp_node.pos[0] - temp_node.parent.pos[0], temp_node.pos[1] - temp_node.parent.pos[1]))

                temp_node = temp_node.parent

            if len(prev_path) == 0 or not (len(prev_path) == limit and len(set(prev_path)) == 1):
                possible_paths.append(path)

        for new_pos in possible_paths:
            node_pos = (curr_node.pos[0] + new_pos[0],
                        curr_node.pos[1] + new_pos[1])

            new_node = Node(curr_node, node_pos)

            children.append(new_node)

        for child in children:

            for closed_child in closed_list:
                if child == closed_child:
                    continue

            child.g = curr_node.g + 1
            child.h = max(
                abs(child.pos[0] - dest_node.pos[0]), abs(child.pos[1] - dest_node.pos[1]))

            for open_node in open_list:
                if child == open_node and child.g > open_node.g:
                    continue

            open_list.append(child)

    current_streak = 0
    return current_streak


def print_path(path):
    print('Total Distance: ', len(path))
    for i in path[:-1]:
        print(i, end=' -> ')
    print(path[-1])


src = (0, 0)
x=int(input('Enter x point of the coordinate : '))
y=int(input('Enter y point of the coordinate : '))
dest = (x,y)

print_path(get_path(src, dest))
